<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 2px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 7px #1E92FB, 0 0 4px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: transparent;    /*上边框颜色*/
        border-left-color: transparent;    /*左边框颜色*/
    }
</style>








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/yi.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/yi.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript 高级," />










<meta name="description" content="JavaScript 高级面向对象编程什么是面向对象？ 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。 因此，面向对象编程具有">
<meta name="keywords" content="JavaScript 高级">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 高级">
<meta property="og:url" content="http://yoursite.com/zh-cn/2017/03/19/JavaScript高级/index.html">
<meta property="og:site_name" content="嗯，一点余温">
<meta property="og:description" content="JavaScript 高级面向对象编程什么是面向对象？ 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。 因此，面向对象编程具有">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-08-11T05:39:48.535Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 高级">
<meta name="twitter:description" content="JavaScript 高级面向对象编程什么是面向对象？ 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。 因此，面向对象编程具有">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/zh-cn/2017/03/19/JavaScript高级/"/>





  <title>JavaScript 高级 | 嗯，一点余温</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?01076d8c1ebce03ed408a2a36a23aa85";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/yidianyuwen" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">嗯，一点余温</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Shiyi_</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/zh-cn/2017/03/19/JavaScript高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Shiyi_">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嗯，一点余温">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript 高级</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-19T21:12:27+08:00">
                2017-03-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript-高级/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript 高级</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JavaScript-高级"><a href="#JavaScript-高级" class="headerlink" title="JavaScript 高级"></a>JavaScript 高级</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>什么是面向对象？</p>
<p>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。</p>
<p>它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。</p>
<p>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>面向对象与面向过程：</p>
<ul>
<li>面向过程就是亲历亲为，事无巨细，面面俱到，步步紧跟，有条不紊，面向过程是解决问题的一种思维方式，关注点在于解决问题的过程。</li>
<li>面向对象就是找一个对象，指挥得结果，解决问题的思维方式，关注点在解决问题的对象上。</li>
<li>面向对象将执行者转变成指挥者</li>
<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
</ul>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><ol>
<li>封装性：<ul>
<li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象对象的内部具体实现，这就是封装。</li>
</ul>
</li>
<li>继承性：<ul>
<li>在js中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承。</li>
<li>注意：在其他语言里面，继承是类与类之间的关系，在js中，是对象与对象之间的关系。</li>
</ul>
</li>
<li>多态性：<ul>
<li>多态是在强类型的语言中才有的。js是弱类型语言，所以JS不支持多态。</li>
</ul>
</li>
</ol>
<h2 id="prototype-原型"><a href="#prototype-原型" class="headerlink" title="prototype 原型"></a>prototype 原型</h2><p>什么叫原型：</p>
<ul>
<li>任何一个函数，都有一个属性，prototype 值是一个对象</li>
<li>把函数的 prototype 指向的这个对象就叫做原型。</li>
<li>原型内所有的属性和方法都可以被这个构造函数new出来的实例访问。</li>
</ul>
<p>原型的作用： 存储一些所有实例需要共享的内容，比如方法。</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。</p>
<h3 id="原型（prototype）的概念"><a href="#原型（prototype）的概念" class="headerlink" title="原型（prototype）的概念"></a>原型（prototype）的概念</h3><p>JavaScript中任何一个函数都有一个属性，prototype指向一个对象，这个函数构造的所有实例都可以继承这个对象的所有属性和方法；</p>
<h3 id="原型（prototype）的作用"><a href="#原型（prototype）的作用" class="headerlink" title="原型（prototype）的作用"></a>原型（prototype）的作用</h3><p>原型（prototype）的作用是存储所有实例需要共享和继承的属性和方法；</p>
<h3 id="构造函数，实例，原型之间的关系"><a href="#构造函数，实例，原型之间的关系" class="headerlink" title="构造函数，实例，原型之间的关系"></a>构造函数，实例，原型之间的关系</h3><p>构造函数：构造函数就是一个函数，配合new可以新建对象。</p>
<p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例。</p>
<p>原型：每一个构造函数都有一个属性prototype，这个属性就叫做原型属性。通过构造函数创建出来的实例能够直接使用原型上的属性和方法。</p>
<p>构造函数：其实就一个函数,通常来说，构造函数的首字母要大写。构造函数要通过new来使用。构造函数的作用：实例化对象。</p>
<p>实例(对象)： 任何一个对象都是由构造函数new出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;  <span class="comment">// var obj = new Object();</span></span><br><span class="line"><span class="keyword">var</span> arr = [];  <span class="comment">// var arr = new Array();</span></span><br></pre></td></tr></table></figure>
<p>原型：任何一个构造函数，都会有一个prototype属性，原型可以理解为构造函数的配偶，或者是实例的父亲。原型就是一个对象。 默认的原型对象只有一个属性：constructor的属性，指向了构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype == 实例.__proto__</span><br></pre></td></tr></table></figure>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__ 属性"></a><code>__proto__</code> 属性</h3><p>通过构造函数创建的对象，自带一个 <code>__proro__</code> 属性，这个属性指向了构造函数的prototype属性，也就是原型对象。</p>
<p>获取原型对象：</p>
<ul>
<li>通过 <code>构造函数.prototype</code> 可以获取</li>
<li>通过 <code>实例.__proto__</code> 可以获取（隐式原型）</li>
<li>它们指向了同一个 <code>对象构造函数.prototype === 实例.__proto__</code></li>
</ul>
<p>【<strong>注意：<code>__proto__</code> 是浏览器的一个隐藏（私有）属性，早期的IE浏览器不支持，不要去修改它，如果要修改原型中的内容，使用 <code>构造函数.prototype</code> 去修改</strong>】</p>
<h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>默认情况下，原型对象中值包含了一个属性：constructor，constructor属性指向了当前的构造函数。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样一环扣一环就形成了一个链式结构，我们把这个链式结构称为：原型链。</p>
<p>总结：<code>Object.prototype</code> 是原型链的尽头，<code>Object.prototype</code> 的原型是 <code>null</code>。</p>
<p>任何一个函数，都会有 prototype 属性。 任何一个对象，都会有(原型)<code>__proto__</code>，这个原型又是一个对象，所以原型也会原型(<code>__proto__</code>),一环扣一环，就形成了一个链式的结构，我们把这个链式结构就叫做原型链。</p>
<ol>
<li>所有的函数的都是 <code>new Fucntion</code> 创建出来的，<code>函数.__proto__ === Function.prototype</code></li>
<li>所有的原型都是 <code>new Object</code> 创建出来的，<code>原型.__proto__ === Object.prototype</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>【<strong>Math是一个对象。</strong>】</p>
<h3 id="原型链属性查找原则"><a href="#原型链属性查找原则" class="headerlink" title="原型链属性查找原则"></a>原型链属性查找原则</h3><p>如果是获取操作</p>
<ol>
<li>会先在自身上查找，如果没有</li>
<li>则根据 <code>__proto__</code> 对应的原型去找，如果没有</li>
<li>一直找到 <code>Object.prototyp</code>，如果没有，那就找不到了，返回 <code>undefined</code>。（万物皆对象）</li>
<li>当我们访问某个对象的属性的时候， 先找自己的属性，如果有，直接返回；如果没有，沿着原型链一直找到 <code>Object.prototype</code>，如果还没有，就会返回 <code>undefined</code>。</li>
</ol>
<p>如果是修改操作</p>
<ul>
<li>只会修改对象自身的属性，如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性。</li>
<li>如果对象自己有，就覆盖原来的值。如果对象没有，就增加一个值。</li>
</ul>
<h2 id="Object-prototype成员介绍"><a href="#Object-prototype成员介绍" class="headerlink" title="Object.prototype成员介绍"></a>Object.prototype成员介绍</h2><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a><code>hasOwnProperty()</code></h3><p><code>hasOwnProperty()</code> 方法会返回一个布尔值，判断某个属性是否是对象自己的属性。</p>
<ul>
<li>如果是自己的属性，会返回true。</li>
<li>如果不是自己的属性或者这个属性不存在，都会返回false。</li>
</ul>
<h4 id="hasOwnProperty与in的区别"><a href="#hasOwnProperty与in的区别" class="headerlink" title="hasOwnProperty与in的区别"></a>hasOwnProperty与in的区别</h4><p>in操作符：如果属性不是自己提供的，是从原型上继承来的，也会返回true；</p>
<p>hasOwnProperty: 该属性必须是自己提供，才返回true，否则返回false。</p>
<h3 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable()"></a><code>propertyIsEnumerable()</code></h3><p><code>propertyIsEnumerable()</code> 方法返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性。</p>
<ul>
<li>该属性必须是可枚举，即可以被for..in遍历</li>
<li>该属性必须是自身属性。</li>
</ul>
<p><code>Object.defineProperty()</code> 了解</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：需要给哪个对象添加属性</span></span><br><span class="line"><span class="comment">//第二个参数：给对象添加的属性的名字</span></span><br><span class="line"><span class="comment">//第三个参数：给属性添加的修饰，是一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"age"</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'gender'</span>, &#123;</span><br><span class="line">  <span class="comment">//value: "女", //该属性对应的值，默认是undefined</span></span><br><span class="line">  configurable: <span class="literal">true</span>, <span class="comment">//默认为false，为true时，才可以修改值和删除</span></span><br><span class="line">  enumerable: <span class="literal">false</span>, <span class="comment">//默认为false，为true时才可以被for..in遍历</span></span><br><span class="line">  <span class="comment">//writable: false, //默认为false， 为true才可以被赋值运算符改变</span></span><br><span class="line">  <span class="comment">//当获取属性值的时候，get方法会被调用</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get执行了"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//该方法将接受唯一参数，并将该参数的新值分配给该属性。</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = val;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"set执行了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.gender = <span class="string">"男"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.gender);</span><br></pre></td></tr></table></figure>
<h3 id="valueOf-toString-toLocalString"><a href="#valueOf-toString-toLocalString" class="headerlink" title="valueOf()/toString()/toLocalString()"></a><code>valueOf()/toString()/toLocalString()</code></h3><ul>
<li><code>valueOf()</code> 会返回对象的原始值，我们不需要手动的调用这个方法，当我们需要使用到原始值的时候，JavaScript会自动的调用他。</li>
<li><code>toString()</code> 方法返回一个表示该对象的字符串。当对象需要转换为一个字符串的时候，toString方法会被调用</li>
<li><code>toLocaleString()</code> 方法返回一个该对象的字符串表示。该方法主要用于被本地化相关对象覆盖。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/5.1/#sec-8.12.8</a></li>
<li><a href="http://lzw.me/pages/ecmascript/#100‘" target="_blank" rel="noopener">http://lzw.me/pages/ecmascript/#100‘</a></li>
<li>当一个对象需要转换成字符串类型的时候，会调用 <code>tostring()</code> 方法，如果需要转换成原始值，会调用 <code>valueOf()</code> 方法。<ol>
<li>如果是Date类型，会默认先调用 <code>toString()</code> 方法，如果 <code>toString()</code> 类型没有获取到原始值，就会调用 <code>valueOf()</code> 方法</li>
<li>如果是其他类型，会默认先调用 <code>valueOf()</code> 方法，如果 <code>valueOf()</code> 没有获取到原始值，会调用 <code>toString()</code> 方法</li>
<li>如果 <code>toString()</code> 和 <code>valueOf()</code> 方法都没有转换成原始值，就会报错。</li>
</ol>
</li>
</ul>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf()"></a><code>isPrototypeOf()</code></h3><p><code>isPrototypeOf()</code> 用来判断对象</p>
<p><code>isPrototypeOf()</code> 方法用于测试一个对象是否存在于另一个对象的原型链上。</p>
<p><code>A.isPrototypeOf(B)</code> 判断A是否是B的原型或者是原型的原型。说白了就是判断A是否是B的祖先</p>
<p><code>A.isPrototypeOf(B)</code> 判断A是否在B的原型链上；A 是一个原型对象</p>
<p><code>B instanceof A</code> 判断A的prototype是否在B的原型链上；A 是一个构造函数</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 判断的是构造函数（实际执行的是<code>构造函数.prototype</code>）</p>
<p>instanceof 运算符作用和isPrototypeOf类似，用于判断构造函数的prototype属性是否在对象的原型链上。如果是，就返回true，如果不在，就返回false。</p>
<p>语法： 实例对象 instanceof 构造函数</p>
<p>返回值：检测构造函数的prototype属性是否在实例对象的原型链上。</p>
<p><code>A.isPrototypeOf(B)</code> 判断A是否在B的原型链上；A 是一个原型对象<br><code>B instanceof A</code> 判断A的prototype是否在B的原型链上；A 是一个构造函数</p>
<h2 id="函数的四种调用模式（this）"><a href="#函数的四种调用模式（this）" class="headerlink" title="函数的四种调用模式（this）"></a>函数的四种调用模式（this）</h2><p>函数内部可以使用this，这个this是动态的，函数的调用模式不同，this指向的对象也不同；</p>
<h3 id="函数和方法的区别"><a href="#函数和方法的区别" class="headerlink" title="函数和方法的区别"></a>函数和方法的区别</h3><p>对象内部的函数叫方法；</p>
<p>不在一个对象内的函数，叫函数</p>
<h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><p>this指向window <code>函数名();</code></p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><p>this指向当前调用函数的对象 <code>对象名.方法名();</code></p>
<h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><p>this指向 <code>new 构造函数名()</code> 的实例对象；</p>
<h3 id="上下文调用模式（方法借调模式）"><a href="#上下文调用模式（方法借调模式）" class="headerlink" title="上下文调用模式（方法借调模式）"></a>上下文调用模式（方法借调模式）</h3><h4 id="call"><a href="#call" class="headerlink" title="call()"></a><code>call()</code></h4><h5 id="call函数调用"><a href="#call函数调用" class="headerlink" title="call函数调用"></a>call函数调用</h5><p><code>fn.call()</code> 所有的函数都可以使用call进行调用；</p>
<p>参数1：指定函数的this，如果不传，则this指向window</p>
<p>其余参数：和函数的参数列表一模一样。</p>
<p>说白了，call方法也可以和()一样，进行函数调用，call方法的第一个参数可以指定函数内部的this指向。</p>
<p><code>fn.call(thisArg, arg1, arg2, arg2);</code></p>
<p>thisArg：this指向对象，如果不传，则this指向window</p>
<p>arg1, arg2, arg2：形参</p>
<h5 id="方法借调"><a href="#方法借调" class="headerlink" title="方法借调"></a>方法借调</h5><p><code>obj2.方法名.call(obj1)</code> obj2借用obj2的方法</p>
<p>伪数组也叫类数组</p>
<ol>
<li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有length属性，也有0,1,2,3等属性。</li>
<li>伪数组并没有数组的方法，不能使用push/pop等方法</li>
<li>伪数组可以跟数组一样进行遍历，通过下标操作。</li>
<li>常见的伪数组：<code>arguments</code>、<code>document.getElementsByTagName</code>的返回值、jQuery对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>:<span class="string">"张三"</span>,</span><br><span class="line">  <span class="number">1</span>:<span class="string">"李四"</span>,</span><br><span class="line">  <span class="number">2</span>:<span class="string">"王五"</span>,</span><br><span class="line">  length:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//伪数组可以和数组一样进行遍历</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//伪数组借用数组的方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(arrLike, <span class="string">"赵六"</span>);</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(arrLike, <span class="string">"-"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将伪数组转换成真数组</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.prototype.slice.call(arrLike);</span><br></pre></td></tr></table></figure>
<p>借调的时候，调用了这个函数；this指向传入的参数；</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><code>apply()</code></h4><p><code>apply()</code> 方法</p>
<p><code>apply()</code> 方法的作用和 <code>call()</code> 方法类似，只有一个区别，就是 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
<p>而call()方法接受的是若干个参数的列表</p>
<p><code>apply(thisArg, Array)</code> 不传递参数默认指向window；参数格式固定，可以不写，</p>
<p>thisArg：this指向的对象</p>
<p>Array：所有实参组成的数组</p>
<p>call和apply的使用场景：</p>
<ul>
<li>如果参数比较少，使用call会更加简洁</li>
<li>如果参数存放在数组中，此时需要使用apply</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">951</span>, <span class="number">357</span>, <span class="number">654</span>, <span class="number">852</span>];</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr);</span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Math</span>.min.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">951</span>, <span class="number">357</span>, <span class="number">654</span>, <span class="number">852</span>);</span><br><span class="line"><span class="built_in">console</span>.log(num1);</span><br><span class="line"><span class="built_in">console</span>.log(num2);</span><br></pre></td></tr></table></figure>
<h2 id="沙箱模式"><a href="#沙箱模式" class="headerlink" title="沙箱模式"></a>沙箱模式</h2><p>沙箱，沙盒，沙盘：这是一个独立的环境，这里面的任何变量都是这个环境中的变量，与外部无关；</p>
<p>函数自调用就是一个沙箱模式，自调用函数内部不会影响到外部；</p>
<p>如果想让一个变量可以被外部调用，在自调用函数结尾的地方使用 <code>window.变量名 = 变量</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//如果想让这个函数变成外部的全局变量，赋值给window</span></span><br><span class="line"><span class="built_in">window</span>.fn = fn;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="comment">//形参：window，可以被压缩</span></span><br><span class="line"><span class="comment">//实参：window</span></span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，</p>
<p>只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承；</p>
<h3 id="混入式继承（mixin）"><a href="#混入式继承（mixin）" class="headerlink" title="混入式继承（mixin）"></a>混入式继承（mixin）</h3><p>把一个对象中的属性和方法拷贝到另一个对象中；</p>
<h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>直接给原型添加属性和方法</p>
<p>替换原型，在替换的对象中加入constructor:构造函数名；</p>
<p>混入式继承+原型替换</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a><code>Object.create</code></h3><p>最初是由道格拉斯丶克罗克福德发布的一篇文章提出的，ECMAScript5新增了 <code>Object.create()</code> 方法来规范化了这种继承。</p>
<p>ES5中新增了一个方法 <code>Object.create()</code>,方法会使用指定的原型对象及其属性去创建一个新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数：proto 一个对象</span></span><br><span class="line"><span class="comment">//返回值：obj 新对象，新对象的原型就是 proto</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(lw);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="built_in">console</span>.log(o.__proto__ == lw);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="函数声明的三种方式"><a href="#函数声明的三种方式" class="headerlink" title="函数声明的三种方式"></a>函数声明的三种方式</h3><p>函数声明  <code>function fn() {}</code></p>
<p>函数表达式 <code>var fn = function () {}</code></p>
<p>构造函数 <code>var fn = new Function()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数也是对象，可以使用Function构造函数new出来</span></span><br><span class="line"><span class="comment">//相当于var fn = function()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：new Function(arg1,arg2,arg3..,body);</span></span><br><span class="line"><span class="comment">// 1. 所有的参数都是字符串类型。</span></span><br><span class="line"><span class="comment">// 2. 前面可以定义任意多个形参，最后一个参数是代码体。</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(1111)"</span>);</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"alert(a1+a2)"</span>);</span><br><span class="line">fn1(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>所见即所得函数</p>
<p>new Function可以让一段字符串当成代码来执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"var n1 = 1; var n2 = 2; console.log(n1 + n2)"</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(str);</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><p>eval是一函数，作用可以执行一段js程序；</p>
<p>eval的可以和new Function一样，执行字符串代码</p>
<p>注意：eval函数的功能非常的强大，但是实际使用的情况并不多。</p>
<p>eval形式的代码难以阅读；eval形式的代码无法打断点，因为本质还是还是一个字符串；在浏览器端执行任意的 JavaScript 会带来潜在的安全风险，恶意的JavaScript代码可能会破坏应用；</p>
<h3 id="立即执行函数-自调用函数"><a href="#立即执行函数-自调用函数" class="headerlink" title="立即执行函数/自调用函数"></a>立即执行函数/自调用函数</h3><p>自调用函数前面用分号开头，防止上一行代码没有用分号结束，而被浏览器默认连接在一起；</p>
<p><code>;()()</code></p>
<p><code>() [] // `</code> :`之前的代码必须使用分号结束</p>
<h3 id="函数的原型链"><a href="#函数的原型链" class="headerlink" title="函数的原型链"></a>函数的原型链</h3><p>函数也是一个对象：函数是由<code>new Function</code>创建出来的，因此函数也是一个对象，所有的函数都是<code>new Function</code>的实例。</p>
<p>函数的完整版原型链</p>
<ol>
<li>所有的函数的都是 <code>new Fucntion</code> 创建出来的，<code>函数.__proto__ === Function.prototype</code></li>
<li>所有的原型都是 <code>new Object</code> 创建出来的，<code>原型.__proto__ === Object.prototype</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype；</span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype；</span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype；</span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype；</span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h2 id="ECMAScript-族谱"><a href="#ECMAScript-族谱" class="headerlink" title="ECMAScript 族谱"></a>ECMAScript 族谱</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);</span><br></pre></td></tr></table></figure>
<h2 id="预解析与作用域"><a href="#预解析与作用域" class="headerlink" title="预解析与作用域"></a>预解析与作用域</h2><h3 id="预解析详解"><a href="#预解析详解" class="headerlink" title="预解析详解"></a>预解析详解</h3><p>预解析：预先解析</p>
<p>js执行代码分为两个过程：</p>
<ul>
<li>预解析过程（变量与函数提升）</li>
<li>代码一行一行执行</li>
</ul>
<p>预解析过程：JavaScript解析器在执行代码前，会把所有变量的声明和函数的声明提升到当前作用域的顶部。例如<code>var a = 11;</code>其实会分为<code>var a;</code> 和 <code>a = 11</code>两部分，其中<code>var a;</code>会被提升。</p>
<p>预解析规则：</p>
<ol>
<li>函数优先，先提升function，后提升var</li>
<li>遇到重名的var会被忽略。</li>
<li>遇到重名的function会被覆盖。</li>
</ol>
<p>推荐：不要在一个作用域内重复的声明相同的变量和函数</p>
<h3 id="作用域详解"><a href="#作用域详解" class="headerlink" title="作用域详解"></a>作用域详解</h3><p>作用域：变量起作用的区域，作用域决定了一个变量被定义在哪里，以及该如何被查找。</p>
<p>全局变量：在函数外定义的变量就叫全局变量，全局变量在任何地方都能访问到。</p>
<p>局部变量：在函数内定义的变量就叫局部变量，局部变量只有在当前函数内才能访问到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">11</span>;<span class="comment">//全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num1 = <span class="number">22</span>;<span class="comment">//局部变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(num1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>编程语言中，作用域规则分为两种：</p>
<ul>
<li>词法作用域（静态作用域）</li>
<li>动态作用域</li>
</ul>
<p>JavaScript采用的是词法作用域规则，词法作用域也叫静态作用域，变量在函数声明的时候，它的作用域就定下来了，与函数的调用无关。</p>
<p>JavaScript使用的是词法作用域（静态作用域）；</p>
<p>函数在声明的时候，作用域就已经确定了；</p>
<p>函数内部的变量查找，与函数在哪里调用无关，只与函数声明的作用域有关；this指向另说；</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个条作用域链。</p>
<p>变量的搜索原则：</p>
<ol>
<li>从当前作用域开始搜索变量，如果存在，那么就直接返回这个变量的值。</li>
<li>如果不存在，就会往上一层作用域查询，如果存在，就返回。</li>
<li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果不存在说明该变量是不存在的。</li>
<li>如果一个变量不存在<ul>
<li>获取这个变量的值会报错xxx is not defined;，</li>
<li>给这个变量设置值，那么设置变量就是隐式全局变量。</li>
</ul>
</li>
</ol>
<p>全局作用域只要页面不卸载，就一直存在，不释放。</p>
<p>函数每次在调用时，都会形成一个作用域，当函数调用结束时，这个作用域就释放了。</p>
<h2 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h2><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包的基本概念</p>
<p>If you can’t explain it to a six-year-old, you really don’t understand it yourself.</p>
<p>闭包（closure）是JavaScript语言的一个难点，也是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。</p>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数</p>
<p>在JavaScript中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。</p>
<p>闭包中包含了内部函数的代码，以及所需外部函数中的变量的引用</p>
<p>【<strong>产生闭包的条件：当内部函数访问了外部函数的变量的时候，就会形成闭包。</strong>】</p>
<p>【<strong>当内部函数访问了外部函数的变量的时候，就会形成闭包。当一个函数访问另一个函数内的局部变量，只有在内外函数的情况。</strong>】</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><p>计数器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：统计一个函数的调用次数</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"我被调用了，调用次数是"</span>+count);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br><span class="line">fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">缺点：count是全局变量，不安全。</span></span><br><span class="line"><span class="comment">使用闭包解决这个问题！！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"当前count"</span>+count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = outer();</span><br><span class="line">result();</span><br></pre></td></tr></table></figure>
<p>私有变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现私有变量的读取和设置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">set_num</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    num = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">get_num</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    set_num:set_num,</span><br><span class="line">    get_num:get_num</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = outer();</span><br><span class="line">obj.set_num(<span class="number">2000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.get_num());</span><br></pre></td></tr></table></figure>
<p>实现缓存</p>
<p>缓存（cache）：数据的缓冲区，当要读取数据时，先从缓冲中获取数据，如果找到了，直接获取，如果找不到，重新去请求数据。</p>
<p>计算斐波那契数列，会有很大的性能问题，因为重复的计算了很多次，因此我们可以使用缓存来解决这个性能问题。</p>
<p>初级优化：</p>
<p>使用缓存的基本步骤：</p>
<ul>
<li>如果要获取数据，先查询缓存，如果有就直接使用</li>
<li>如果没有，就进行计算，并且将计算后的结果放到缓存中，方便下次使用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>);</span><br><span class="line">    arr[n] = temp;<span class="comment">//存入缓存</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：既然使用缓存，就需要保证缓存的数据的安全，不能被别人修改，因此，需要使用闭包来实现缓存的私有化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//缓存</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> fbi = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arr[n]) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[n];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> temp = fbi(n - <span class="number">1</span>) + fbi(n - <span class="number">2</span>);</span><br><span class="line">    arr[n] = temp;<span class="comment">//存入缓存</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fbi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fbi = outer();</span><br><span class="line"><span class="built_in">console</span>.log(fbi(<span class="number">40</span>));</span><br></pre></td></tr></table></figure>
<h3 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h3><p>闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用。</p>
<h3 id="js的垃圾回收机制"><a href="#js的垃圾回收机制" class="headerlink" title="js的垃圾回收机制"></a>js的垃圾回收机制</h3><p>引用计数法清除</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  name:<span class="string">"zs"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象被o变量引用  ，引用记数1</span></span><br><span class="line"><span class="keyword">var</span> obj = o;   <span class="comment">//变量被o和obj引用，引用记数2</span></span><br><span class="line"></span><br><span class="line">o = <span class="number">1</span>;  <span class="comment">//o不在引用对象了， 引用记数1</span></span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//obj不在引用对象了，引用记数0，可以被垃圾回收了。</span></span><br></pre></td></tr></table></figure>
<p>标记清除法清除</p>
<p>使用引用计数法进行垃圾回收的时候，会出现循环引用导致内存泄漏的问题。因此现代的浏览器都采用标记清除法来进行垃圾回收。</p>
<p>这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象Window）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。</p>
<p>从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用，经常用于表单校验，高级搜索等。</p>
<h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h3><ul>
<li>构造函数的方式 <code>var regExp = new RegExp(/\d/);</code></li>
<li>正则字面量  <code>var regExp = /\d/;</code></li>
<li>正则的使用 <code>/\d/.test(&quot;aaa1&quot;);</code></li>
</ul>
<h3 id="普通元字符"><a href="#普通元字符" class="headerlink" title="普通元字符"></a>普通元字符</h3><ul>
<li><code>/abc/</code></li>
<li><code>/123/</code></li>
<li><code>/:,汉字等/</code></li>
<li>点要用转义字符 <code>\.</code></li>
</ul>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义。</p>
<ul>
<li><code>\d</code> <code>[0-9]</code> 数字字符</li>
<li><code>\D</code> <code>[^0-9]</code> 非数字字符</li>
<li><code>\s</code> <code>[\f\r\n\t\v]</code> 不可见字符</li>
<li><code>\S</code> <code>[^\f\r\n\t\v]</code> 可见字符</li>
<li><code>\w</code> <code>[a-zA-Z0-9_]</code> word字符</li>
<li><code>\W</code> <code>[^a-zA-Z0-9_]</code> 非word字符</li>
<li><code>.</code> <code>[^\n\r]</code> 除了换行和回车之外的所有字符</li>
</ul>
<p><code>|</code> 表示或的意思</p>
<p><code>()</code> 优先级最高，表示分组</p>
<h3 id="字符类元字符"><a href="#字符类元字符" class="headerlink" title="字符类元字符"></a>字符类元字符</h3><p><code>[a-z]</code> <code>[1-9]</code> 表示范围</p>
<p><code>[]</code> 在正则表达式中表示一个字符的位置，<code>[]</code> 里面写这个位置可以出现的字符。</p>
<p><code>[^]</code> 在中括号中^表示非的意思；表示该位置不可以出现的字符；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[abc]/</span>);<span class="comment">//匹配a,b,c；</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[^abc]/</span>);<span class="comment">//匹配除了a，b，c以外的其他字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-z]/</span>.test(<span class="string">"d"</span>));<span class="comment">//小写字母</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[A-Z]/</span>.test(<span class="string">"d"</span>));<span class="comment">//大写字母</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[0-9]/</span>.test(<span class="string">"8"</span>));<span class="comment">//数字</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/[a-zA-Z0-9]/</span>);<span class="comment">//所有的小写字母和大写字母以及数字</span></span><br></pre></td></tr></table></figure>
<h3 id="边界类元字符"><a href="#边界类元字符" class="headerlink" title="边界类元字符"></a>边界类元字符</h3><p><code>^</code> 表示以 <code>^</code> 之后的字符开始，精确匹配</p>
<p><code>$</code> 表示以 <code>$</code> 之前的字符结尾，精确匹配</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan/</span>.test(<span class="string">"dachuan"</span>));<span class="comment">//必须以chuan开头</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/chuan$/</span>.test(<span class="string">"chuang"</span>));<span class="comment">//必须以chuan结尾</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan$/</span>.test(<span class="string">"chuan"</span>));<span class="comment">//精确匹配chuan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//精确匹配chuan,表示必须是这个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^chuan$/</span>.test(<span class="string">"chuanchuan"</span>));<span class="comment">//fasle</span></span><br></pre></td></tr></table></figure>
<h3 id="量词类元字符"><a href="#量词类元字符" class="headerlink" title="量词类元字符"></a>量词类元字符</h3><p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p>
<ul>
<li><code>*</code> 表示出现0次或者多次，<code>&gt;=0</code></li>
<li><code>+</code> 表示最少出现一次或者多次，<code>&gt;=1</code></li>
<li><code>?</code> 表示只能出现0次或者1次，<code>=0或者=1</code></li>
<li><code>{n}</code> 表示出现n次，<code>=n</code></li>
<li><code>{n,}</code> 表示最少出现n次，<code>&gt;=n</code></li>
<li><code>{n,m}</code> 表示可以出现n到m次，<code>n&lt;=x&lt;=m</code></li>
</ul>
<h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><p><code>g</code> <code>global</code> 全局查找<br><code>i</code> <code>ignore</code> 忽视大小写</p>
<h3 id="正则表达式的使用"><a href="#正则表达式的使用" class="headerlink" title="正则表达式的使用"></a>正则表达式的使用</h3><p>正则的使用：</p>
<ol>
<li>字符串替换: <code>replace</code> 正则的替换</li>
<li>字符串匹配：<code>match</code> 匹配某个字符串中所有符合规律的字符串。</li>
<li>正则的测试：<code>test</code> 表单校验，判断某个字符串是否符合正则的规律</li>
<li>正则的提取： 提取匹配的字符串的每一个部分。<code>()</code> 进行分组</li>
</ol>
<ul>
<li>正则测试 <code>.test(String);</code> 测试字符串，是否满足正则表达式，返回值是布尔类型</li>
<li>正则提取 <code>.exec(String);</code> 提取满足正则表达式的字符串，返回值是一个数组</li>
<li>正则匹配 <code>String.match(正则表达式g);</code> 把所有满足的正则表达式的字符串返回，返回值是一个数组</li>
<li>正则替换 <code>String.replace(正则表达式g,替换成xx);</code> 把所有满足正则表达式的字符替换成xx</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">正则测试</span><br><span class="line"><span class="number">1.</span> 验证座机</span><br><span class="line">   - 比如<span class="number">010</span><span class="number">-12345678</span>  <span class="number">0797</span><span class="number">-1234567</span></span><br><span class="line">   - 开头是<span class="number">3</span><span class="number">-4</span>位，首位必须是<span class="number">0</span></span><br><span class="line">   - -后面是<span class="number">7</span><span class="number">-8</span>位</span><br><span class="line">       <span class="keyword">var</span> phoneReg = <span class="regexp">/^0\d&#123;2,3&#125;-\d&#123;7,8&#125;$/</span>;</span><br><span class="line"><span class="number">2.</span> 验证姓名</span><br><span class="line">   - 只能是汉字</span><br><span class="line">   - 长度<span class="number">2</span><span class="number">-6</span>位之间</span><br><span class="line">   - 汉字范围[\u4e00-\u9fa5]</span><br><span class="line">       <span class="keyword">var</span> nameReg = <span class="regexp">/^[\u4e00-\u9fa5]&#123;2,6&#125;$/</span>;</span><br><span class="line"><span class="number">3.</span> 验证QQ</span><br><span class="line">   - 只能是数字</span><br><span class="line">   - 开头不能是<span class="number">0</span></span><br><span class="line">   - 长度为<span class="number">5</span><span class="number">-11</span>位</span><br><span class="line">       <span class="keyword">var</span> qqReg = <span class="regexp">/^[1-9]\d&#123;4,10&#125;$/</span>;</span><br><span class="line"><span class="number">4.</span> 验证手机</span><br><span class="line">   - <span class="number">11</span>位数字组成</span><br><span class="line">   - 号段<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>] <span class="number">147</span> <span class="number">15</span>[<span class="number">0</span><span class="number">-9</span>] <span class="number">177</span>[<span class="number">0178</span>] <span class="number">18</span>[<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">       <span class="keyword">var</span> mobileReg = <span class="regexp">/^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d&#123;8&#125;$/</span>;</span><br><span class="line"><span class="number">5.</span> 验证邮箱</span><br><span class="line">   - 前面是字母或者数字</span><br><span class="line">   - 必须有@</span><br><span class="line">   - @后面是字母或者数字</span><br><span class="line">   - 必须有.</span><br><span class="line">   - .后面是字母或者数字</span><br><span class="line">       <span class="keyword">var</span> emailReg = <span class="regexp">/^\w+@\w+(\.\w+)+$/</span>;</span><br><span class="line"></span><br><span class="line">正则提取</span><br><span class="line">reg.test(字符串)  正则测试某个字符串是否符合规则，，，一般用在表达校验。</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/1[3-9]\d&#123;9&#125;/</span>.test(<span class="string">"18511223344"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^1[3-9]\d&#123;9&#125;$/</span>.test(<span class="string">"1851122334411111111"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//今天是2018-05-11， 要求；得到年月日;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今天是2018-05-11， 要求；得到年月日"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提取，分组的概念，，，，如果不分组，提取只能拿到符合规律的整个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正则的方法：test exec</span></span><br><span class="line"><span class="keyword">var</span> arr = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 今年是2018年12月25日</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"今年是2018年12月25日"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)年(\d&#123;2&#125;)月(\d&#123;2&#125;)日/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = reg.exec(str);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line">正则匹配</span><br><span class="line"><span class="comment">//需求：</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"我的手机号是：18511241111， 我的女朋友的手机号是：13211111111，我的前女友的手机号是：18522223333，我的前前女友的手机号是：18511112293"</span>;</span><br><span class="line"><span class="comment">//需求：把字符串中所有的手机号找出来。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会返回满足正则条件的字符串，返回一个数组</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/1[3-9]\d&#123;9&#125;/g</span>));</span><br><span class="line"></span><br><span class="line">正则替换</span><br><span class="line"><span class="comment">// 字符串.replace方法</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"aa bb cc dd ee bb"</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/bb/g</span>, <span class="string">"gg"</span>);<span class="comment">// g: global: 找到所有bb</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"   123AD  asadf   asadfasf  adf aD Ad "</span>;</span><br><span class="line"><span class="comment">//1  替换掉字符串中的所有空白</span></span><br><span class="line"><span class="comment">//2. 将所有的ad替换成xx</span></span><br><span class="line"><span class="comment">//3. 将所有的ad/AD替换成xx</span></span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>, <span class="string">""</span>);</span><br><span class="line">str = str.replace(<span class="regexp">/ad/g</span>, <span class="string">"xx"</span>);</span><br><span class="line">str = str.replace(<span class="regexp">/ad/gi</span>, <span class="string">"xx"</span>);<span class="comment">//  g:global:全局查找   i:ignore:忽视大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//var str = abc,efg,123,abc,123,a</span></span><br><span class="line"><span class="comment">//4. 所有的逗号替换成句号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">'[&#123;"name":"张三",score:80&#125;,&#123;"name":"张三",score:9&#125;,&#123;"name":"张三",score:81&#125;]'</span>;</span><br><span class="line"><span class="comment">//  //5. 把所有成绩都修改成100分</span></span><br><span class="line">jsonStr = jsonStr.replace(<span class="regexp">/\d&#123;1,2&#125;/g</span>, <span class="string">"100"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(jsonStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"a-b-c-d"</span>;<span class="comment">//a,b,c,d</span></span><br></pre></td></tr></table></figure>
<h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><p>JavaScript是单线程</p>
<p>JavaScript是单线程的，在执行JavaScript代码时遇见定时器，事件等不是立即执行的代码，会交给浏览器（浏览器是多线程的），浏览器会开启一个队列，把JavaScript交给浏览器的代码，排列在队列中，在JavaScript执行完代码后，会将队列中的符合执行条件的代码执行；</p>
<h2 id="运算符相关"><a href="#运算符相关" class="headerlink" title="运算符相关"></a>运算符相关</h2><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="=赋值运算符"></a><code>=</code>赋值运算符</h3><p>赋值运算符是一个表达式，这个表达式会有一个结果，是=右边的结果；相当于函数返回了一个结果；</p>
<p>赋值运算符会把一个值赋值给一个变量，这个表达式也会有一个结果；可以用 <code>console.log</code> 来打印这个结果测试；</p>
<p><code>(foo.bar = foo.bar) ()</code> 这里是一个赋值运算表达式，给一个方法赋值了一个函数，但是括号内的这个运算表达式也产生了一个结果，就是右边的方法函数，所以会是函数调用；</p>
<p><code>,</code>逗号运算符</p>
<p>逗号运算符和赋值运算符一样；也产生了一个结果；</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript-高级/" rel="tag"><i class="fa fa-tag"></i> JavaScript 高级</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/zh-cn/2017/02/25/BOM/" rel="next" title="WebApi_BOM">
                <i class="fa fa-chevron-left"></i> WebApi_BOM
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/zh-cn/2017/04/27/JQuery/" rel="prev" title="JQuery">
                JQuery <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="Shiyi_" />
            
              <p class="site-author-name" itemprop="name">Shiyi_</p>
              <p class="site-description motion-element" itemprop="description">凭借自己的意志的话，罪与罚也都是全部由自己产生的，这些，都是理想的一部分；但，如果那些都是借来的，你所宣扬的就全都是空想。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yidianyuwen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="Shiyidejavu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-E-Mail"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/DejavuShiyi" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-高级"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 高级</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程"><span class="nav-number">1.1.</span> <span class="nav-text">面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象编程三大特性"><span class="nav-number">1.1.1.</span> <span class="nav-text">面向对象编程三大特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#prototype-原型"><span class="nav-number">1.2.</span> <span class="nav-text">prototype 原型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型（prototype）的概念"><span class="nav-number">1.2.1.</span> <span class="nav-text">原型（prototype）的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型（prototype）的作用"><span class="nav-number">1.2.2.</span> <span class="nav-text">原型（prototype）的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数，实例，原型之间的关系"><span class="nav-number">1.2.3.</span> <span class="nav-text">构造函数，实例，原型之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proto-属性"><span class="nav-number">1.2.4.</span> <span class="nav-text">__proto__ 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor属性"><span class="nav-number">1.2.5.</span> <span class="nav-text">constructor属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原型链"><span class="nav-number">1.3.</span> <span class="nav-text">原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链属性查找原则"><span class="nav-number">1.3.1.</span> <span class="nav-text">原型链属性查找原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-prototype成员介绍"><span class="nav-number">1.4.</span> <span class="nav-text">Object.prototype成员介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hasOwnProperty-NaN"><span class="nav-number">1.4.1.</span> <span class="nav-text">hasOwnProperty()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hasOwnProperty与in的区别"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">hasOwnProperty与in的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#propertyIsEnumerable-NaN"><span class="nav-number">1.4.2.</span> <span class="nav-text">propertyIsEnumerable()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valueOf-toString-toLocalString"><span class="nav-number">1.4.3.</span> <span class="nav-text">valueOf()/toString()/toLocalString()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isPrototypeOf-NaN"><span class="nav-number">1.4.4.</span> <span class="nav-text">isPrototypeOf()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#instanceof"><span class="nav-number">1.4.5.</span> <span class="nav-text">instanceof</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的四种调用模式（this）"><span class="nav-number">1.5.</span> <span class="nav-text">函数的四种调用模式（this）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数和方法的区别"><span class="nav-number">1.5.1.</span> <span class="nav-text">函数和方法的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数调用模式"><span class="nav-number">1.5.2.</span> <span class="nav-text">函数调用模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用模式"><span class="nav-number">1.5.3.</span> <span class="nav-text">方法调用模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数调用模式"><span class="nav-number">1.5.4.</span> <span class="nav-text">构造函数调用模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#上下文调用模式（方法借调模式）"><span class="nav-number">1.5.5.</span> <span class="nav-text">上下文调用模式（方法借调模式）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#call"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">call()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#call函数调用"><span class="nav-number">1.5.5.1.1.</span> <span class="nav-text">call函数调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方法借调"><span class="nav-number">1.5.5.1.2.</span> <span class="nav-text">方法借调</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">apply()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#沙箱模式"><span class="nav-number">1.6.</span> <span class="nav-text">沙箱模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.7.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#混入式继承（mixin）"><span class="nav-number">1.7.1.</span> <span class="nav-text">混入式继承（mixin）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型链继承"><span class="nav-number">1.7.2.</span> <span class="nav-text">原型链继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-create"><span class="nav-number">1.7.3.</span> <span class="nav-text">Object.create</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数进阶"><span class="nav-number">1.8.</span> <span class="nav-text">函数进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明的三种方式"><span class="nav-number">1.8.1.</span> <span class="nav-text">函数声明的三种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#eval函数"><span class="nav-number">1.8.2.</span> <span class="nav-text">eval函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行函数-自调用函数"><span class="nav-number">1.8.3.</span> <span class="nav-text">立即执行函数/自调用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的原型链"><span class="nav-number">1.8.4.</span> <span class="nav-text">函数的原型链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ECMAScript-族谱"><span class="nav-number">1.9.</span> <span class="nav-text">ECMAScript 族谱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预解析与作用域"><span class="nav-number">1.10.</span> <span class="nav-text">预解析与作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#预解析详解"><span class="nav-number">1.10.1.</span> <span class="nav-text">预解析详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域详解"><span class="nav-number">1.10.2.</span> <span class="nav-text">作用域详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词法作用域"><span class="nav-number">1.10.3.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域链"><span class="nav-number">1.10.4.</span> <span class="nav-text">作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数闭包"><span class="nav-number">1.11.</span> <span class="nav-text">函数闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的概念"><span class="nav-number">1.11.1.</span> <span class="nav-text">闭包的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包的应用"><span class="nav-number">1.11.2.</span> <span class="nav-text">闭包的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包存在的问题"><span class="nav-number">1.11.3.</span> <span class="nav-text">闭包存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js的垃圾回收机制"><span class="nav-number">1.11.4.</span> <span class="nav-text">js的垃圾回收机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则表达式"><span class="nav-number">1.12.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建正则表达式"><span class="nav-number">1.12.1.</span> <span class="nav-text">创建正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#普通元字符"><span class="nav-number">1.12.2.</span> <span class="nav-text">普通元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元字符"><span class="nav-number">1.12.3.</span> <span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符类元字符"><span class="nav-number">1.12.4.</span> <span class="nav-text">字符类元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界类元字符"><span class="nav-number">1.12.5.</span> <span class="nav-text">边界类元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#量词类元字符"><span class="nav-number">1.12.6.</span> <span class="nav-text">量词类元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式修饰符"><span class="nav-number">1.12.7.</span> <span class="nav-text">正则表达式修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正则表达式的使用"><span class="nav-number">1.12.8.</span> <span class="nav-text">正则表达式的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Event-loop"><span class="nav-number">1.13.</span> <span class="nav-text">Event loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符相关"><span class="nav-number">1.14.</span> <span class="nav-text">运算符相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值运算符"><span class="nav-number">1.14.1.</span> <span class="nav-text">=赋值运算符</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2016 -- 2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shiyi_</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>



<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
